<script setup lang="ts">
import { computed, onBeforeUnmount, onMounted, ref, toRef, watch } from "vue";
import { useResizeObserver } from "@vueuse/core";
import { storeToRefs } from "pinia";
import throttle from "raf-throttle";

import type { XY } from "@/api/gateway-api/generated-api";
import { useCanvasStore } from "@/store/canvas";
import {
  type FloatingContainerProperties,
  useCanvasFloatingContainer,
} from "../../CanvasAnchoredComponents/useCanvasFloatingContainer";

/*
 * The FloatingMenu component is a container that can be sticked to a position on the canvas,
 * but is shown on top of the whole application.
 *
 * For stickiness, it observes changes to its own size, and to scroll and zoom changes of the canvas
 *
 * If the menu wants to be closed it emits @menu-close event.
 * The menu will be closed on `esc` key press or on click away.
 *
 */

type Props = FloatingContainerProperties & {
  /**
   * Whether the menu should be prevented from moving out of sight
   */
  preventOverflow?: boolean;

  /**
   * Position of the target the floating menu is attached to in canvas coordinates
   */
  canvasPosition: XY;

  /**
   * Which corner of the floating menu should stick to target position
   */
  anchor?: "top-left" | "top-right" | "bottom-left" | "bottom-right";

  /**
   * A constant offset value added to `left` when computing the anchor position
   */
  leftOffset?: number;

  /**
   * A constant offset value added to `top` when computing the anchor position
   */
  topOffset?: number;
};

const props = withDefaults(defineProps<Props>(), {
  preventOverflow: false,
  anchor: "top-left",
  leftOffset: 0,
  topOffset: 0,
  disableInteractions: false,
  closeOnEscape: true,
  focusTrap: false,
});

const emit = defineEmits(["menuClose"]);

const absolutePosition = ref({ left: 0, top: 0 });

const canvasStore = useCanvasStore();

const { zoomFactor } = storeToRefs(canvasStore);

const rootEl = ref<HTMLDivElement>();
const menuElementHeight = computed(() => {
  return rootEl.value?.offsetHeight ?? 0;
});

useCanvasFloatingContainer({
  rootEl,
  focusTrap: toRef(props, "focusTrap"),
  closeMenu: () => emit("menuClose"),
  canvasStore,
  disableInteractions: props.disableInteractions,
  closeOnEscape: props.closeOnEscape,
});

const distanceToCanvas = ({ left, top }: { left: number; top: number }) => {
  let kanvas = document.getElementById("kanvas")!;
  let { y, x, width, height } = kanvas.getBoundingClientRect();

  // find distance of point to all edges
  let leftDistance = x - left;
  let rightDistance = left - x - width;
  let topDistance = y - top;
  let bottomDistance = top - y - height;

  // find distance to closest horizontal edge, if outside canvas
  let distanceX = Math.max(Math.max(leftDistance, rightDistance), 0);

  // find distance to closest vertical edge, if outside canvas
  let distanceY = Math.max(Math.max(topDistance, bottomDistance), 0);

  // return greatest distance
  return Math.max(distanceX, distanceY);
};

const setAbsolutePosition = () => {
  if (!rootEl.value) {
    return;
  }

  // get position relative to the window
  let { x: left, y: top } = canvasStore.screenFromCanvasCoordinates(
    props.canvasPosition,
  );

  // if the target point is outside the canvas, first reduce opacity then close menu
  let distance = distanceToCanvas({ left, top });

  // linear fading depending on distance
  const distanceThreshold = 50;

  let alpha = Math.max(0, distanceThreshold - distance) / distanceThreshold;
  rootEl.value.style.opacity = alpha.toString();

  // close menu if outside threshold
  if (distance > distanceThreshold) {
    emit("menuClose");
    return;
  }

  const menuWidth = rootEl.value.offsetWidth;
  const menuHeight = rootEl.value.offsetHeight;

  switch (props.anchor) {
    case "top-right":
      left -= menuWidth;
      break;
    case "bottom-left":
      top -= menuHeight;
      break;
    case "bottom-right":
      left -= menuWidth;
      top -= menuHeight;
      break;
  }

  top -= props.topOffset;
  left -= props.leftOffset;

  if (props.preventOverflow) {
    // ensure the menu is always visible within the window
    if (window.innerWidth - left < menuWidth) {
      left = window.innerWidth - menuWidth;
    } else if (left < 0) {
      left = 0;
    }

    // ensure the menu is always visible within the window
    if (window.innerHeight - top < menuHeight) {
      top = window.innerHeight - menuHeight;
    } else if (top < 0) {
      top = 0;
    }
  }

  absolutePosition.value = { left, top };
};

watch(menuElementHeight, () => {
  setAbsolutePosition();
});

watch([zoomFactor, toRef(props, "canvasPosition")], () => {
  setAbsolutePosition();
});

const onCanvasScroll = throttle(function () {
  setAbsolutePosition();
});

useResizeObserver(rootEl, () => {
  setAbsolutePosition();
  consola.trace("floating menu: resize detected");
});

onMounted(() => {
  setAbsolutePosition();

  let kanvas = document.getElementById("kanvas")!;
  kanvas.addEventListener("scroll", onCanvasScroll);
});

onBeforeUnmount(() => {
  // if kanvas currently exists (workflow is open) remove scroll event listener
  let kanvas = document.getElementById("kanvas")!;
  kanvas?.removeEventListener("scroll", onCanvasScroll);
});
</script>

<template>
  <div
    ref="rootEl"
    class="floating-menu"
    :style="{
      left: `${absolutePosition.left}px`,
      top: `${absolutePosition.top}px`,
    }"
  >
    <slot />
  </div>
</template>

<style lang="postcss" scoped>
.floating-menu {
  position: absolute;
  display: block;
  z-index: v-bind("$zIndices.layerExpandedMenus");

  &:focus {
    outline: none;
  }
}
</style>
